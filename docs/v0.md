# Rust

Rust is a relatively young systems-level programming language that can be compiled to native code for various platforms.
The Rust compiler enforces strict ownership using compile time type checking, which provides memory safety without the added overhead by running a garbage collector.
Initially developed by engineers at Mozilla to provide an easier tool to solve concurrency related problems in their C++ codebase for Firefox, Rust is currently maintained completely by its community.
Friends of functional programming might especially find Rust syntax rather pleasing.

## Preliminaries

### Calling Rust functions from C++

In order to avoid writing two separate programs for benchmarking, one for C++ and one for Rust, we would rather write Rust functions that the C++ linker will understand.
This would allow us to compile our Rust code into static libraries, which we can then link to our benchmarking program written in C++.

Consider the following C++ declaration of the `step` function:
```cpp
    extern "C" {
        void step(float*, const float*, int);
    }
```
Implementing the declared function in Rust is rather easy, but requires some wrapper code:
```rust
    #[no_mangle]
    pub unsafe extern "C" fn step(r_raw: *mut f32, d_raw: *const f32, n: i32) {
        let d = std::slice::from_raw_parts(d_raw, (n * n) as usize);
        let mut r = std::slice::from_raw_parts_mut(r_raw, (n * n) as usize);
        _step(&mut r, d, n as usize);
    }
```

Let's break that down.

We use a compile-time [attribute](https://doc.rust-lang.org/reference/attributes.html#miscellaneous-attributes) which instructs the compiler to retain the symbol name of the function (`step`), without name mangling:
```rust
    #[no_mangle]
```

We declare an [`extern`](https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code) Rust function with public visibility, using the C-language application binary interface (ABI):
```rust
    pub unsafe extern "C" fn step(r_raw: *mut f32, d_raw: *const f32, n: i32) {
```
The function arguments should be rather easy to figure out when compared side to side with the C++ declaration of the `step` function.

The [`unsafe`](https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html#unsafe-rust) keyword is a rather powerful feature of Rust, which basically disables most (but not all) of the compile-time memory safety analysis within a block of code.
In exchange, we are allowed to e.g. dereference raw pointers inside the scope that is declared unsafe, which would be a compile time error in "not-unsafe" sections.
Note that the unsafe scope does not extend to functions invoked inside the unsafe section, which in this case is only the 3 lines of `step`.

Instead of declaring all our functions unsafe and keep passing around raw pointers like in C, we wrap the raw pointers into [slices](https://doc.rust-lang.org/std/primitive.slice.html).
Slices are Rust primitive types which provide a dynamically-sized view into a block of memory.

Here, we construct an immutable slice of length `n * n`, starting at the address pointed by `d_raw`:
```rust
        let d = std::slice::from_raw_parts(d_raw, (n * n) as usize);
```

We wrap `r_raw` also into a slice, but declare it mutable to allow writing into its memory block:
```rust
        let mut r = std::slice::from_raw_parts_mut(r_raw, (n * n) as usize);
```

Now we have two "not-unsafe" Rust primitive types that point to the memory blocks passed down by the C++ program calling our `step` function.
We can proceed by calling our Rust function [`_step`](/src/rust/v0_baseline/src/lib.rs), which provides the actual Rust implementation of the [step](http://ppc.cs.aalto.fi/ch2/) function:
```rust
        _step(&mut r, d, n as usize);
```

### Further reading

* [On the Rust FFI](https://blog.rust-lang.org/2015/04/24/Rust-Once-Run-Everywhere.html)
* [Rust for C++ programmers](https://github.com/nrc/r4cppp)
